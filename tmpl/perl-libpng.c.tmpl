#include <stdarg.h>
#include <png.h>

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "perl-libpng.h"

#ifdef HEADER

typedef struct perl_libpng {
    png_structp png;
    png_infop info;
    png_infop end_info;
    void * row_pointers;
}
perl_libpng_t;

typedef perl_libpng_t [% config.base_underscore %]__Libpng__t;

#endif

#define pngi png->png, png->info

/* The following macro is used for useless arguments from libpng which
   are always set to zero. It is not used for arguments which are set
   to zero for some other reason than because they are useless
   (e.g. flush functions which are set to zero because we don't need
   them). */

#define UNUSED_ZERO_ARG 0

/* The following time fields are used in "perl_png_timep_to_hash" for
   converting the PNG modification time structure ("png_time") into a
   Perl associative array. */

static const char * time_fields[] = {
    "year",
    "month",
    "day",
    "hour",
    "minute",
    "second"
};

#define N_TIME_FIELDS (sizeof (time_fields) / sizeof (const char *))

/* Return an undefined value. */

#define UNDEF return &PL_sv_undef

static perl_libpng_t *
perl_png_allocate ()
{
    perl_libpng_t * png = calloc (1, sizeof (perl_libpng_t));
    return png;
}

perl_libpng_t *
perl_png_create_write_struct ()
{
    perl_libpng_t * png = perl_png_allocate ();
    png->png = png_create_write_struct (PNG_LIBPNG_VER_STRING, 0, 0, 0);
    png->info = png_create_info_struct (png->png);
    png->end_info = 0;
    png->row_pointers = 0;
    return png;
}

perl_libpng_t *
perl_png_create_read_struct ()
{
    perl_libpng_t * png = perl_png_allocate ();
    png->png = png_create_read_struct (PNG_LIBPNG_VER_STRING, 0, 0, 0);
    png->info = png_create_info_struct (png->png);
    png->row_pointers = 0;
    return png;
}

perl_png_destroy_write_struct (perl_libpng_t * png)
{
    png_destroy_write_struct (& png->png, & png->info);
    if (png->row_pointers) {
        free (png->row_pointers);
    }
    free (png);
}

perl_png_destroy_read_struct (perl_libpng_t * png)
{
    png_destroy_read_struct (& png->png, & png->info, & png->end_info);
    free (png);
}


/* "perl_png_timep_to_hash" converts a PNG time structure to a Perl
   associative array with named fields of the same name as the members
   of the C structure. */

void perl_png_timep_to_hash (const png_timep mod_time, HV * time_hash)
{
    int i;
    SV * f[N_TIME_FIELDS];
    f[0] = newSViv (mod_time->year);
    f[1] = newSViv (mod_time->month);
    f[2] = newSViv (mod_time->day);
    f[3] = newSViv (mod_time->hour);
    f[4] = newSViv (mod_time->minute);
    f[5] = newSViv (mod_time->second);
    for (i = 0; i < N_TIME_FIELDS; i++) {
        if (!hv_store (time_hash, time_fields[i],
                       strlen (time_fields[i]), f[i], 0)) {
            fprintf (stderr, "hv_store failed.\n");
        }
    }
}

/* Print a warning message. */

static void perl_png_warn (const char * format, ...)
{
    va_list ap;
    va_start (ap, format);
    vfprintf (stderr, "format", ap);
    va_end (ap);
}

/* Create a scalar value from the "text" field of the PNG text chunk
   contained in "text_ptr". */

static SV * make_text_sv (const png_textp text_ptr)
{
    SV * sv;
    char * text = 0;
    int length = 0;

    if (text_ptr->text) {
        text = text_ptr->text;
        if (text_ptr->text_length != 0) {
            length = text_ptr->text_length;
        }
        else if (text_ptr->itxt_length != 0) {
            length = text_ptr->itxt_length;
        }
    }
    if (text && length) {

        /* "is_itxt" contains a true value if the text claims to be
           ITXT (international text) and also validates as UTF-8
           according to Perl. The PNG specifications require that ITXT
           text is UTF-8 encoded, but this routine checks that here
           using Perl's "is_utf8_string" function. */

        int is_itxt = 0;

        sv = newSVpvn (text, length);
        
        if (text_ptr->compression == PNG_ITXT_COMPRESSION_NONE ||
            text_ptr->compression == PNG_ITXT_COMPRESSION_zTXt) {

            is_itxt = 1;

            if (! is_utf8_string ((unsigned char *) text, length)) {
                perl_png_warn ("According to its compression type, a text chunk in the current PNG file claims to be ITXT but Perl's 'is_utf8_string' says that its encoding is invalid.");
                is_itxt = 0;
            }
        }
        if (is_itxt) {
            SvUTF8_on (sv);
        }
    }
    else {
        sv = newSV (0);
    }
    return sv;
}

/* Convert the "lang_key" field of a "png_text" structure into a Perl
   scalar. */

static SV * lang_key_to_sv (const char * lang_key)
{
    SV * sv;
    if (lang_key) {
        int length;
        /* "lang_key" is supposed to be UTF-8 encoded. */
        int is_itxt = 1;

        length = strlen (lang_key);
        sv = newSVpv (lang_key, length);
        if (! is_utf8_string ((unsigned char *) lang_key, length)) {
            perl_png_warn ("A language key 'lang_key' member of a 'png_text' structure in the file failed Perl's 'is_utf8_string' test, which says that its encoding is invalid.");
            is_itxt = 0;
        }
        if (is_itxt) {
            SvUTF8_on (sv);
        }
    }
    else {
        sv = newSV (0);
    }
    return sv;
}

/* "text_fields" contains the names of the various fields in a
   "png_text" structure. The following routine uses these names to put
   the values of the png_text structure into a Perl hash. */

static const char * text_fields[] = {
    "compression",
    "key",
    "text",
    "lang",
    "lang_key",
    "text_length",
    "itxt_length",
};

/* "N_TEXT_FIELDS" is the number of text fields in a "png_text"
   structure which we want to preserve. */

#define N_TEXT_FIELDS (sizeof (text_fields) / sizeof (const char *))

/* "perl_png_textp_to_hash" creates a new Perl associative array from
   the PNG text values in "text_ptr". */

static HV *
perl_png_textp_to_hash (const png_textp text_ptr)
{
    int i;
    /* Scalar values which will be added to elements of "text_hash". */
    SV * f[N_TEXT_FIELDS];
    HV * text_hash;

    text_hash = newHV ();
    f[0] = newSViv (text_ptr->compression);
    f[1] = newSVpv (text_ptr->key, strlen (text_ptr->key));
    /* Depending on whether the "text" field of "text_ptr" is a string
       or a null value, create an SV copy of it or create an SV which
       contains the undefined value. */
    f[2] = make_text_sv (text_ptr);
    if (text_ptr->lang) {
        /* According to section 4.2.3.3 of the PNG specification, the
           "lang" field of the "png_text" structure contains a
           language code according to the conventions of RFC 1766 (now
           superceded by RFC 3066), which is an ASCII based standard
           for describing languages, so it is not necessary to mark
           this as being in UTF-8. */
        f[3] = newSVpv (text_ptr->lang, strlen (text_ptr->lang));
    }
    else {
        /* The language code may be empty. */
        f[3] = newSV (0);
    }
    f[4] = lang_key_to_sv (text_ptr->lang_key);
    f[5] = newSViv (text_ptr->text_length);
    f[6] = newSViv (text_ptr->itxt_length);

    for (i = 0; i < N_TEXT_FIELDS; i++) {
        //printf ("%d:%s\n", i, text_fields[i]);
        if (!hv_store (text_hash, text_fields[i],
                       strlen (text_fields[i]), f[i], 0)) {
            fprintf (stderr, "hv_store failed.\n");
        }
    }

    return text_hash;
}

/*
  This is the C part of [% config.base %]::get_text.
 */

SV *
perl_png_get_text (perl_libpng_t * png)
{
    int num_text = 0;
    png_textp text_ptr;

    png_get_text (pngi, & text_ptr, & num_text);

    if (num_text > 0) {
        int i;
        SV * text_ref;
        AV * text_chunks;

        text_chunks = newAV ();
        for (i = 0; i < num_text; i++) {
            HV * hash;
            SV * hash_ref;
            
            hash = perl_png_textp_to_hash (text_ptr + i);
            hash_ref = newRV_inc ((SV *) hash);
            av_push (text_chunks, hash_ref);
        }
        return (SV *) text_chunks;
    } else {
        UNDEF;
    }
}

/* If the PNG contains a valid time, put the time into a Perl
   associative array. */

HV * 
perl_png_get_time (perl_libpng_t * png)
{
    png_timep mod_time = 0;
    int status;
    HV * time;

    time = newHV ();
    status = png_get_tIME (pngi, & mod_time);
    if (status && mod_time) {
        perl_png_timep_to_hash (mod_time, time);
    }
    else {
        fprintf (stderr, "No time info in PNG file.\n");
    }
    return time;
}

int
perl_png_sig_cmp (SV * png_header, int start, int num_to_check)
{
    unsigned char * header;
    unsigned int length;
    int ret_val;
    header = (unsigned char *) SvPV (png_header, length);
    ret_val = png_sig_cmp (header, start, num_to_check);
    return ret_val;
}

typedef struct {
    SV * png_image;
    const char * data; 
    int read_position;
    unsigned int length;
}
scalar_as_image_t;

/* Read some bytes from a Perl scalar into a png->png as requested. */

static void
perl_png_scalar_read (png_structp png,
                      png_bytep out_bytes,
                      png_size_t byte_count_to_read)
{
    scalar_as_image_t * si;
    const char * read_point;

    si = png_get_io_ptr (png);
#if 0
    fprintf (stderr, "Reading %d bytes from image at position %d.\n",
             byte_count_to_read, si->read_position);
#endif
    if (si->read_position + byte_count_to_read > si->length) {
        fprintf (stderr, "Request for too many bytes %d on an image "
                 "of length %d at read position %d.\n",
                 byte_count_to_read, si->length, si->read_position);
        return;
    }
    read_point = si->data + si->read_position;
    memcpy (out_bytes, read_point, byte_count_to_read);
    si->read_position += byte_count_to_read;
}

/* Read a PNG from a Perl scalar "image_data". */

void
perl_png_read_from_scalar (perl_libpng_t * png,
                           SV * image_data,
                           int transforms)
{
    scalar_as_image_t si = {0};

    fprintf (stderr, "Setting up the image.\n");
    /* We don't need the following anywhere. However we probably
       should keep track of where the data comes from. */
    si.png_image = image_data;
    si.data = SvPV (si.png_image, si.length);
    /* Check it is a valid PNG here using png_sig_cmp. */

    /* Set the reader for png->png to our function. */
    png_set_read_fn (png->png, & si, perl_png_scalar_read);
    png_read_png (png->png, png->info, transforms, UNUSED_ZERO_ARG);
}

static void
perl_png_scalar_write (png_structp png, png_bytep bytes_to_write,
                       png_size_t byte_count_to_write)
{
    scalar_as_image_t * si;

    si = png_get_io_ptr (png);
    if (si->png_image == 0) {
        si->png_image = newSVpv (bytes_to_write, byte_count_to_write);
    }
    else {
        sv_catpvn (si->png_image, bytes_to_write, byte_count_to_write);
    }
}

/* Write the PNG image data into a Perl scalar. */

SV *
perl_png_write_to_scalar (perl_libpng_t * png, int transforms)
{
    scalar_as_image_t * si;
    si = calloc (1, sizeof (scalar_as_image_t));
    SV * image_data;

    fprintf (stderr, "Setting up the image.\n");
    /* Set the writer for png->png to our function. */
    png_set_write_fn (png->png, si, perl_png_scalar_write,
                      0 /* No flush function */);
    png_write_png (pngi, transforms, UNUSED_ZERO_ARG);
    image_data = si->png_image;
    free (si);
    return image_data;
}

HV *
perl_png_get_IHDR (perl_libpng_t * png)
{
    png_uint_32 width;
    png_uint_32 height;
    int bit_depth;
    int color_type;
    int interlace_method;
    int compression_method;
    int filter_method;
    /* libpng return value */
    int status;
    /* The return value. */
    HV * IHDR;

    IHDR = newHV ();
    status = png_get_IHDR (pngi, & width, & height,
                           & bit_depth, & color_type, & interlace_method,
                           & compression_method, & filter_method);
#define STORE(x) {                                                      \
        if (!hv_store (IHDR, #x, strlen (#x), newSViv (x), 0)) {        \
            fprintf (stderr, "hv_store failed.\n");                     \
        }                                                               \
    }
    STORE (width);
    STORE (height);
    STORE (bit_depth);
    STORE (color_type);
    STORE (interlace_method);
    STORE (compression_method);
    STORE (filter_method);
#undef STORE

    return IHDR;
}

#define PERL_PNG_COLOR_TYPE(x)                  \
 case PNG_COLOR_TYPE_ ## x:                     \
     name = #x;                                 \
     break

/* Convert a PNG colour type number into its name. */

const char * perl_png_color_type_name (int color_type)
{
    const char * name;

    switch (color_type) {
        PERL_PNG_COLOR_TYPE (GRAY);
        PERL_PNG_COLOR_TYPE (PALETTE);
        PERL_PNG_COLOR_TYPE (RGB);
        PERL_PNG_COLOR_TYPE (RGB_ALPHA);
        PERL_PNG_COLOR_TYPE (GRAY_ALPHA);
    default:
        /* Moan about not knowing this colour type. */
        name = "";
    }
    return name;
}

#define PERL_PNG_TEXT_COMP(x,y)                  \
    case PNG_ ## x ## _COMPRESSION_ ## y:        \
    name = #x "_" #y;                            \
    break

/* Convert a libpng text compression number into its name. */

const char * perl_png_text_compression_name (int text_compression)
{
    const char * name;
    switch (text_compression) {
        PERL_PNG_TEXT_COMP(TEXT,NONE);
        PERL_PNG_TEXT_COMP(TEXT,zTXt);
        PERL_PNG_TEXT_COMP(ITXT,NONE);
        PERL_PNG_TEXT_COMP(ITXT,zTXt);
    default:
        /* Moan about not knowing this text compression type. */
        name = "";
    }
    return name;
}

#undef PERL_PNG_COLOR_TYPE

/* Return an array of hashes containing the colour values of the palette. */

AV *
perl_png_get_PLTE (perl_libpng_t * png)
{
    png_colorp colours;
    int n_colours;
    png_uint_32 status;
    int i;
    AV * perl_colours;

    status = png_get_PLTE (pngi, & colours, & n_colours);
    perl_colours = newAV ();
    if (status != PNG_INFO_PLTE) {
        return perl_colours;
    }
    for (i = 0; i < n_colours; i++) {
        HV * palette_entry;

        //        printf ("Palette entry %d\n", i);
        palette_entry = newHV ();
#define PERL_PNG_STORE_COLOUR(x) hv_store (palette_entry, #x, strlen (#x), \
                           newSViv (colours[i].x), 0)
        PERL_PNG_STORE_COLOUR (red);
        PERL_PNG_STORE_COLOUR (green);
        PERL_PNG_STORE_COLOUR (blue);
#undef PERL_PNG_STORE_COLOUR
        av_push (perl_colours, newRV ((SV *) palette_entry));
    }
    return perl_colours;
}

void
perl_png_set_PLTE (perl_libpng_t * png, AV * perl_colors)
{
    int n_colors;
    png_colorp colors;
    int i;

    n_colors = av_len (perl_colors) + 1;
    if (n_colors == -1) {
        fprintf (stderr, "Empty array.\n");
        return;
    }
    //    printf ("There are %d colours in the palette.\n", n_colors);

    colors = calloc (n_colors, sizeof (png_color));

    /* Put the colours from Perl into the libpng structure. */

#define PERL_PNG_FETCH_COLOR(x) {                                       \
        SV * rgb_sv = * (hv_fetch (palette_entry, #x, strlen (#x), 0)); \
        colors[i].x = SvIV (rgb_sv);                                    \
    }
    for (i = 0; i < n_colors; i++) {
        HV * palette_entry;
        SV * color_i;

        color_i = * av_fetch (perl_colors, i, 0);
        palette_entry = (HV *) SvRV (color_i);

        PERL_PNG_FETCH_COLOR (red);
        PERL_PNG_FETCH_COLOR (green);
        PERL_PNG_FETCH_COLOR (blue);
    }

#undef PERL_PNG_FETCH_COLOR

    png_set_PLTE (pngi, colors, n_colors);
    free (colors);
}

/* Create a hash containing the colour values of a pointer to a
   png_color_16 structure. */

static HV * perl_png_color_16_to_hv (png_color_16p colour)
{
    HV * perl_colour;
    perl_colour = newHV ();
#define PERL_COLOUR(x) \
    hv_store (perl_colour, #x, strlen (#x), newSViv (colour->x), 0)
    PERL_COLOUR(index);
    PERL_COLOUR(red);
    PERL_COLOUR(green);
    PERL_COLOUR(blue);
    PERL_COLOUR(gray);
#undef PERL_COLOUR
    return perl_colour;
}

#define VALID(x) png_get_valid (pngi, PNG_INFO_ ## x)
#undef UNDEF
#define UNDEF return newHV ()

HV * perl_png_get_bKGD (perl_libpng_t * png)
{
    if (VALID(bKGD)) {
        png_color_16p background;
        if (png_get_bKGD (pngi, & background)) {
            return perl_png_color_16_to_hv (background);
        }
    }
    UNDEF;
}

HV * perl_png_get_cHRM (perl_libpng_t * png)
{
    if (VALID (cHRM)) {
        HV * ice;
        ice = newHV ();
        return ice;
    }
    UNDEF;
}

HV * perl_png_get_sBIT (perl_libpng_t * png)
{
    if (VALID (sBIT)) {
    HV * sig_bit;
    sig_bit = newHV ();
    return sig_bit;
    }
    UNDEF;
}

HV * perl_png_get_oFFs (perl_libpng_t * png)
{
    if (VALID (oFFs)) {
    HV * offset;

    offset = newHV ();
    return offset;
    }
    UNDEF;
}

HV * perl_png_get_pHYs (perl_libpng_t * png)
{
    if (VALID (pHYs)) {
    HV * phys;

    phys = newHV ();
    return phys;
    }
    UNDEF;
}

int perl_png_get_sRGB (perl_libpng_t * png)
{
    /* I'm not sure what to return if there is no valid sRGB value. */

    int intent = 0;

    if (VALID (sRGB)) {
        png_get_sRGB (pngi, & intent);
    }
    return intent;
}

HV * perl_png_get_valid (perl_libpng_t * png)
{
    HV * perl_valid;
    unsigned int valid;

    perl_valid = newHV ();
    valid = png_get_valid (pngi, 0xFFFFFFFF);
#define V(x) \
    hv_store (perl_valid, #x, strlen (#x), newSViv (valid & PNG_INFO_ ## x), 0)

    V(gAMA);
    V(sBIT);
    V(cHRM);
    V(PLTE);
    V(tRNS);
    V(bKGD);
    V(hIST);
    V(pHYs);
    V(oFFs);
    V(tIME);
    V(pCAL);
    V(sRGB);
    V(iCCP);
    V(sPLT);
    V(sCAL);
    V(IDAT);

#undef V

    return perl_valid;
}

AV *
perl_png_get_rows (perl_libpng_t * png)
{
    png_bytepp rows;
    int rowbytes;
    int height;
    SV ** row_svs;
    int r;
    AV * perl_rows;

    /* Get the information from the PNG. */

    height = png_get_image_height (pngi);
    if (height == 0) {
        fprintf (stderr, "Image has no height.\n");
        return 0;
        /* We are shafted. */
    }
    else {
        //        printf ("Image has height %d\n", height);
    }
    rows = png_get_rows (pngi);
    if (rows == 0) {
        fprintf (stderr, "Image has no rows.\n");
        return 0;
        /* We are shafted. */
    }
    else {
        //        printf ("Image has some rows\n");
    }
    rowbytes = png_get_rowbytes (pngi);
    if (rowbytes == 0) {
        fprintf (stderr, "Image rows have zero length.\n");
        return 0;
        /* We are shafted. */
    }
    else {
        printf ("Image rows are length %d\n", rowbytes);
    }

    /* Create Perl stuff to put the row info into. */

    row_svs = calloc (height, sizeof (SV *));
    if (! row_svs) {
        /* We are shafted. */
        return 0;
    }
    //    printf ("Making %d scalars.\n", height);
    for (r = 0; r < height; r++) {
        row_svs[r] = newSVpvn (rows[r], rowbytes);
    }
    perl_rows = av_make (height, row_svs);
    //    printf ("There are %d elements in the array.\n", av_len (perl_rows));
    free (row_svs);
    return perl_rows;
}

void perl_png_set_rows (perl_libpng_t * png, AV * rows)
{
    unsigned char ** row_pointers;
    int i;
    int n_rows;

    if (png->row_pointers) {
        fprintf (stderr, "Row pointers already allocated.\n");
        return;
    }
    /* Check that this is the same as the height of the image. */
    n_rows = av_len (rows);
       // printf ("%d rows.\n", n_rows);
    row_pointers = calloc (n_rows, sizeof (unsigned char *));
    if (! row_pointers) {
        fprintf (stderr, "calloc failed.\n");
        return;
    }
    for (i = 0; i <= n_rows; i++) {
        /* Check that this is the same as the width of the image. */
        int length;
        SV * row_i;
        row_i = * av_fetch (rows, i, 0);
        row_pointers[i] = SvPV (row_i, length);
        //        printf ("%d %d\n", i, length);
    }
    png_set_rows (pngi, row_pointers);
    /* Keep a record of the allocated memory in order to free it */
    png->row_pointers = row_pointers;
}

void 
perl_png_set_IHDR (perl_libpng_t * png, HV * IHDR)
{
    /* The first four are set to illegal values. We really should
       check the values going in to this routine. */
    png_uint_32 width = 0;
    png_uint_32 height = 0;
    int bit_depth = 0;
    int color_type = 0;
    int interlace_method = PNG_INTERLACE_NONE;
    const int compression_type = PNG_COMPRESSION_TYPE_DEFAULT;
    const int filter_type = PNG_FILTER_TYPE_DEFAULT;


#define FETCH(x) {                                              \
        SV ** fetched = hv_fetch (IHDR, #x, strlen (#x), 0);    \
        if (fetched) {                                          \
            x = SvIV (*fetched);                                \
        }                                                       \
    }
    FETCH (width);
    FETCH (height);
    FETCH (bit_depth);
    FETCH (color_type);
    FETCH (interlace_method);
    if (width == 0 || height == 0 || bit_depth == 0) {
        fprintf (stderr, "Bad values for width/height/bit depth.\n");
        return;
    }
    png_set_IHDR (pngi, width, height, bit_depth, color_type,
                  interlace_method, compression_type, filter_type);
}

void
perl_png_write_png (perl_libpng_t * png, int transforms)
{
    printf ("Trying to write your crap.\n");
    png_write_png (pngi, transforms, UNUSED_ZERO_ARG);
}

/*
   Local Variables:
   mode: c
   end: 
*/
